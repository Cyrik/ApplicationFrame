{"version":3,"sources":["webpack:///webpack/bootstrap 6104f04fdb40b3b8906a","webpack:///./af/modules/Canvas/lib/VisualComponent.js","webpack:///./af/modules/Canvas/lib/RenderManager.js","webpack:///./af/modules/Canvas/lib/Layer.js","webpack:///./af/modules/Canvas/lib/RenderEngine.js","webpack:///./af/util/make.js","webpack:///./af/core/prototypes/Application.js","webpack:///./af/modules/Canvas/Prototypes/Box.js","webpack:///./af/modules/Canvas/Prototypes/TextBlock.js","webpack:///./af/modules/Canvas/main.js","webpack:///./assets.js","webpack:///./map.js","webpack:///./af/core/prototypes/ApplicationInternal.js","webpack:///./af/modules/Canvas/Prototypes/Image.js","webpack:///./af/modules/Canvas/lib/Canvas.js","webpack:///./af/modules/Canvas/lib/RenderCanvasManager.js","webpack:///./af/modules/Canvas/lib/RenderEngine/TaskList.js","webpack:///./main.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;;;AChEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb,uDAAuD,IAAI;AAC3D;AACA,SAAS;;AAET;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;AC1DA;AACA,UAAU,eAAe;AACzB;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,uBAAuB,mCAAmC;AAC1D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,uBAAuB,kCAAkC;AACzD;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,yCAAyC;AAChE;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,yBAAyB;AACzE;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8DAA8D,QAAQ;AACtE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;;AAEA;;;;;;;;;;;;;;;ACtSA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA,eAAe,cAAc;AAC7B,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA,eAAe,cAAc;AAC7B,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;;;;;;;;;;;;;ACrDA;AAAA;AACA;AACA;;AAEe;AACf;;AAEA,WAAW,WAAW;AACtB;;AAEA,WAAW,WAAW;AACtB;;AAEA,WAAW,6BAA6B;AACxC;;AAEA,WAAW,6BAA6B;AACxC;;AAEA,WAAW,WAAW;AACtB;;AAEA,WAAW,WAAW;AACtB;;AAEA,WAAW,QAAQ;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,uEAAuE,iBAAiB;AACxF;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,wEAAwE,iBAAiB;AACzF;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,SAAS;AACxB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,eAAe,SAAS;AACxB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,EAAE;AAClB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,EAAE,EAAE;AACpB;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,eAAe,SAAS;AACxB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,iCAAiC;AAC7C;AACA;AACA;;;;;;;;;;;;;;;AChOA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,uBAAuB,eAAe;;AAEtC;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,MAAM;AAClB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA,mBAAmB,uBAAuB;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;AC/Ie;AACf;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gDAAgD,UAAU;AAC1D,KAAK;;;AAGL;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB;AACA,eAAe,YAAY;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,eAAe;AACf;AACA;AACA;AACA,kCAAkC,UAAU;;AAE5C;AACA,6BAA6B,KAAK,EAAE,KAAK;AACzC,kCAAkC,4BAA4B;AAC9D,sCAAsC,0BAA0B;;AAEhE;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;ACtHA;;AAEA;;AAEA;;AAEA;AACA,eAAe,kBAAkB;AACjC;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;;;;;;;;;;;;;;ACzBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iDAAiD,YAAY,GAAG,QAAQ;AACxE,uCAAuC,aAAa;;AAEpD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA,0BAA0B,cAAc,KAAK,UAAU;AACvD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA,KAAK;;AAEL;AACA;;AAEA;;;;;;;;;;;;;;;AC1E6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,mBAAmB;AACnB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,CAAC;;AAED;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;;;;;;;;;;;;AC7LF;;AAEA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AACA,wGAAyB,iBAAiB,EAAE,SAAS;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC7CA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACtCA;;AAEA;;AAEA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;;;;;;;;;;;;;;AC5CA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;;AAEA;AACA,4BAA4B;;AAE5B;AACA,0DAA0D,eAAe;AACzE;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;;;;;;;;;;;;AC3CA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACfA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,OAAO;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL,eAAe,OAAO;AACtB;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACyE;AACzE;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA,4IAA6D,uDAAuD;AACpH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA,iDAAiD,IAAI,oBAAoB,OAAO,mBAAmB,SAAS;AAC5G,SAAS;AACT,KAAK;;AAEL;AACA,aAAa,gBAAgB;AAC7B;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb,2BAA2B,kBAAkB;AAC7C;;AAEA,+BAA+B,qBAAqB;AACpD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 16);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6104f04fdb40b3b8906a","import RenderManager from './RenderManager';\n\nconst VisualComponent = {\n\n    _parent: null,\n    _dirty: false,\n\n    x: 0,\n    y: 0,\n\n    height: 0,\n    width: 0,\n\n    $isContainer: false,\n    $isRoot: false,\n    offsetX: 0,\n    offsetY: 0,\n\n    constructor(initialData = {}) {\n        Object.keys(initialData).forEach(key => {\n\n            if (key[0] === '$' || key[0] === '_') {\n                return console.error('unable to overide protected property!');\n            }\n\n            if (Reflect.has(this, key)) {\n                this[key] = initialData[key];\n            } else {\n                console.warn('Af-Canvas:', `property ${key} is not defined on this visual component!`);\n            }\n        });\n\n        return this;\n    },\n\n    getProperty(propName) {\n        return this[propName];\n    },\n\n    setProperty(propName, value) {\n        this[propName] = value;\n\n        if (['x', 'y'].indexOf(propName) > -1 && this._parent) {\n            RenderManager.pushDirtyItem(this._parent, true);\n        } else {\n            RenderManager.pushDirtyItem(this);\n        }\n    },\n\n    render(canvasManager) {\n        const canvas = canvasManager.getCanvas(this).canvas;\n\n        canvas.height = this.height;\n        canvas.width = this.width;\n    }\n\n};\n\nexport default VisualComponent;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./af/modules/Canvas/lib/VisualComponent.js\n// module id = 0\n// module chunks = 0","import RenderEngine from './RenderEngine';\n//import { hasPrototype } from '../../../util/make';\nimport RenderCanvasManager from './RenderCanvasManager';\n\nconst renderCanvas = document.createElement('canvas');\n\nconst RenderManager = {\n\n    _heap: {\n        renderQueue: [],\n        dirtyItems: [],\n        compositeRootList: [],\n        componentBitmapMap: new WeakMap(),\n        elementStack: [],\n    },\n\n    _running: false,\n\n    /**\n     * @param {ViewComponent} item - the dirty item to add\n     * @param {boolean} noMark - should the element be marked dirty\n     * @return {void}\n     */\n    pushDirtyItem(item, noMark = false) {\n        let stack = [item];\n\n        while(stack.length) {\n            let item = stack.pop();\n\n            if (!item) {\n                continue;\n            }\n\n            // we just changed the possition. Keept it as simple as possibe\n            // only add parent to the parent gets restored and we can redraw all children\n\n            item._dirty = !noMark;\n            noMark = false;\n\n            this.addItemToQueue(item);\n\n            if (item.$isContainer) {\n                for (let i = 0; i < item._children.length; i++) {\n                    if (item._children[i].$isContainer) {\n                        stack.push(item._children[i]);\n                    }\n                }\n            }\n            /*\n            if (item.$isContainer && !positionOnly) {\n                for (let i = 0; i < item._children.length; i++) {\n                    if (item.$isContainer) {\n                        stack.push(item._children[i]);\n                    }\n                }\n            }*/\n        }\n\n        this.renderCycle();\n    },\n\n    addItemToQueue(item) {\n        if (this._heap.dirtyItems.indexOf(item) < 0) {\n            this._heap.dirtyItems.push(item);\n        }\n    },\n\n    renderCycle() {\n        if (this._running && this._heap.dirtyItems.length) {\n            RenderEngine.scheduleRenderTask(this.frame.bind(this), 'af-canvas-render-manager');\n        }\n    },\n\n    frame() {\n        try {\n            this.checkTree();\n            this.renderComponents();\n            this.composite();\n            this.renderCycle();\n        } catch (e) {\n            console.error(e);\n            this._running = false;\n            this._heap.renderQueue.length = 0;\n            this._heap.compositeRootList = 0;\n        }\n    },\n\n    renderComponents() {\n        for (let i = 0; i < this._heap.renderQueue.length; i++) {\n            const item = this._heap.renderQueue[i];\n\n            renderCanvas.height = 0;\n            renderCanvas.width = 0;\n\n            const bitmap = item.render(RenderCanvasManager);\n            this._heap.componentBitmapMap.set(item, bitmap);\n            item._dirty = false;\n        }\n\n        this._heap.renderQueue.length = 0;\n    },\n\n    checkTree() {\n        for (let i = 0; i < this._heap.dirtyItems.length; i++) {\n            this.checkDirtyItem(this._heap.dirtyItems[i]);\n        }\n\n        this._heap.dirtyItems.length = 0;\n\n//        console.log(this._heap.renderQueue, this._heap.compositeRootList);\n    },\n\n    /**\n     * draws all the updated components to the canvas while trying to not redraw\n     * pixels which didn't change.\n     *\n     * @return {void}\n     */\n    composite() {\n        const elementStack = this._heap.elementStack;\n        let offsetX = 0;\n        let offsetY = 0;\n\n        // go though the deepest not dirty containers\n        for (let i = 0; i < this._heap.compositeRootList.length; i++) {\n            const element = this._heap.compositeRootList[i];\n\n            elementStack.length = 0;\n\n            // IMPORTANT: we don't use this right now, because it should be easier\n            // to detect this problem when we determine the composite root\n            //\n            // if we are in a container we need to take care of our\n            // greater siblings.\n/**            if (element._parent) {\n                const children = element._parent._children;\n                const currentElementIndex = children.indexOf(element);\n\n                // we push all siblings to the stack which have a higher zIndex\n                // than the current element\n                for (let y = children.length -1; y > currentElementIndex; y--) {\n                    if (this._heap.compositeRootList.indexOf(children[y]) < 0) {\n                        elementStack.push(children[y]);\n                    }\n                }\n            } **/\n\n            // we took care of our siblings, ready to push the current root.\n            elementStack.push(element);\n\n            // process all elements which are either dirty or required to restore a non dirty base\n            while(elementStack.length) {\n                const element = elementStack.pop();\n\n                if (element._cleanUp) {\n                    // we steped back into the layer, clean up time.\n                    offsetX -= element.x;\n                    offsetY -= element.y;\n                    element._cleanUp = false;\n\n                    continue;\n                } else {\n                    // add relative element offset to the absolute offset\n                    offsetX = offsetX + element.x;\n                    offsetY = offsetY + element.y;\n                }\n\n                // this is a container, start pushing it's chilred to the stack\n                // we need to process them too.\n                if (element.$isContainer) {\n\n                    // push element back on to the stack.\n                    if (element._children.length) {\n                        element._cleanUp = true;\n                        elementStack.push(element);\n                    }\n\n                    // push all children in reverse order, this way well will pop\n                    // the lowest child first\n                    for (let y = element._children.length - 1; y > -1; y--) {\n                        elementStack.push(element._children[y]);\n                    }\n                }\n\n                // if the current element is dirty and a container, but not the root,\n                // we will backup the current image data\n                if (element._dirty && element.$isContainer) {\n\n                    // ony backup data if it's not the root\n                    if (!element.$isRoot) {\n                        this.backupImageData(element, offsetX, offsetY);\n                    }\n\n                    element._dirty = false;\n\n                // this is either a not dirty container and we restore the last\n                // clean image data or we just draw an updated component\n                } else {\n                    let bitmap = this._heap.componentBitmapMap.get(element);\n                    let canvas = this.getCanvas(element);\n\n                    // if this is not the root we should have image data for this\n                    // element\n                    if (!element.$isRoot) {\n                        if (element.$isContainer && bitmap) {\n                            this.restoreImageData(canvas, offsetX, offsetY, bitmap);\n                        } else if (bitmap) {\n                            this.drawToCanvas(canvas, offsetX, offsetY, bitmap);\n                        }\n                    }\n\n                    if (!element._cleanUp) {\n                        // we are done, role back the offset update.\n                        offsetX -= element.x;\n                        offsetY -= element.y;\n                    }\n\n                    element._dirty = false;\n                }\n            }\n        }\n\n        this._heap.compositeRootList.length = 0;\n    },\n\n    getCanvas(item) {\n        while (item) {\n            if (item.$isRoot) {\n                return item;\n            } else {\n                item = item._parent;\n            }\n        }\n    },\n\n    backupImageData(element, offsetX, offsetY) {\n        const canvas = this.getCanvas(element).element;\n        const targetCanvas = RenderCanvasManager.getCanvas(element);\n\n        targetCanvas.canvas.height = element.height;\n        targetCanvas.canvas.width = element.width;\n\n        targetCanvas.drawImage(canvas, 0, 0, element.width, element.height,\n                                            offsetX, offsetY, element.width, element.height);\n\n        this._heap.componentBitmapMap.set(element, targetCanvas.canvas);\n    },\n\n    restoreImageData(canvas, x, y, bitmap) {\n        //canvas.drawContext.save();\n        //canvas.drawContext.globalCompositeOperation = 'copy';\n        //canvas.drawContext.clearRect(0, 0, bitmap.width, bitmap.height);\n        canvas.drawContext.drawImage(bitmap, x, y);\n        //canvas.drawContext.restore();\n    },\n\n    drawToCanvas(canvas, x, y, bitmap) {\n        x *= canvas.resolution;\n        y *= canvas.resolution;\n\n        canvas.drawContext.drawImage(bitmap, x, y);\n\n        renderCanvas.height = 0;\n        renderCanvas.width = 0;\n    },\n\n    checkDirtyItem(item) {\n        if (!item._parent && !item.$isRoot) {\n            return;\n        }\n\n        if (item.$isContainer) {\n            if (!item._dirty || item.$isRoot) {\n                this._heap.compositeRootList.push(item);\n            }\n        } else {\n            this._heap.renderQueue.push(item);\n        }\n\n        if (!item.$isRoot && item._dirty) {\n            this.addItemToQueue(item._parent);\n        }\n    },\n\n    start() {\n        this._running = true;\n        this.renderCycle();\n    },\n\n    stop() {\n        this._running = false;\n    },\n};\n\nexport default RenderManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./af/modules/Canvas/lib/RenderManager.js\n// module id = 1\n// module chunks = 0","import RenderManager from './RenderManager';\nimport ViewComponent from './VisualComponent';\n\nconst Layer = {\n\n    $isContainer: true,\n\n    _children: null,\n\n    constructor(...args) {\n        super.constructor(...args);\n\n        this._children = [];\n\n        return this;\n    },\n\n    /**\n     * @param {ViewComponent} child - the child component to add\n     * @return {void}\n     */\n    addChild(child) {\n        this._children.push(child);\n\n        if (child._parent) {\n            child._parent.removeChild(child);\n        } else {\n            RenderManager.pushDirtyItem(child);\n        }\n\n        child._parent = this;\n\n        RenderManager.pushDirtyItem(this);\n    },\n\n    /**\n     * @param {ViewComponent} child - the child to remove\n     * @return {void}\n     */\n    removeChild(child) {\n        if (child._parent !== this) {\n            return console.error(child, 'is not a child of', this);\n        }\n\n        let indexOfChild = this._children.indexOf(child);\n\n        this._children.splice(indexOfChild, 1);\n        RenderManager.pushDirtyItem(this);\n    },\n\n    __proto__: ViewComponent,\n};\n\nexport default Layer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./af/modules/Canvas/lib/Layer.js\n// module id = 2\n// module chunks = 0","/**\n * @module RenderEngine\n */\n\nimport { Make } from '../../../util/make';\nimport TaskList from './RenderEngine/TaskList';\n\n/** @type {Function[]} */\nlet preRenderHooks = [];\n\n/** @type {Function[]} */\nlet postRenderHooks = [];\n\n/** @type {module:RenderEngine.TaskList} */\nlet preRenderTasks = Make(TaskList)();\n\n/** @type {module:RenderEngine.TaskList} */\nlet renderTasks = Make(TaskList)();\n\n/** @type {Function[]} */\nlet postRenderTasks = [];\n\n/** @type {Function[]} */\nlet nextPostRenderTasks = [];\n\n/** @type {boolean} */\nlet active = false;\n\nconst getNow = function() {\n    return window.performance ? window.performance.now() : Date.now();\n};\n\n/**\n * performs all render tasks from one frame. This is one render cycle.\n *\n * @return {void}\n */\nlet renderCycle = function() {\n    active = false;\n\n    const cycleStart = getNow();\n\n    // run all post render hooks after a frame has been painted. So this happens\n    // at the beginning of the next cycle.\n    postRenderHooks.forEach(hook => {\n        const startTime = getNow();\n\n        hook();\n\n        const endTime = getNow();\n        const duration = endTime - startTime;\n\n        if (duration > 100) {\n            console.warn(`a pre render hook is taking too much time! ${duration.round()}ms`);\n        }\n    });\n\n    const startTime = getNow();\n\n    postRenderTasks.forEach(task => {\n        task();\n\n        let endTime = getNow();\n        let duration = endTime - startTime;\n\n        if (duration >= 500) {\n            console.warn(`a post render task is taking too much time! ${duration.round()}ms`);\n        }\n    });\n\n    // init render cycle.\n    // nothing at the moment.\n\n    // run the pre render hooks before we start to do render stuff.\n    preRenderHooks.forEach(hook => hook());\n\n    // run pre render tasks\n    let tasks = preRenderTasks.tasks;\n    preRenderTasks.flush();\n    tasks.forEach(task => task());\n\n    //run all render tasks.\n    tasks = renderTasks.tasks;\n    renderTasks.flush();\n    tasks.forEach(task => task());\n\n    //finish rendering, final steps\n    postRenderTasks = nextPostRenderTasks;\n    nextPostRenderTasks = [];\n\n    //create performance data\n    const cycleDuration = getNow() - cycleStart;\n    const frameRate = 1000 / cycleDuration;\n\n    RenderEngine.performance.lastFrameDuration = cycleDuration;\n    RenderEngine.performance.fps = frameRate;\n    RenderEngine.performance.renderedFrames += 1;\n\n    // done wait for next frame\n    scheduleNextFrame();\n};\n\n/**\n * Schedules a new render cycle in the browsers rendeing engine.\n * The cycle is performed as soon as the browser is ready to render a new frame.\n *\n * @return {void}\n */\nlet scheduleNextFrame = function() {\n    if (!active && (postRenderHooks.length > 0 || preRenderHooks.length > 0 ||\n        renderTasks.length > 0 || postRenderTasks.length > 0 || nextPostRenderTasks.length > 0)) {\n        window.requestAnimationFrame(renderCycle);\n\n        active = true;\n    }\n};\n\n\n/**\n * RenderEngine Singleton\n *\n * @namespace\n */\nlet RenderEngine = {\n\n    performance: {\n        fps: 0,\n        lastFrameDuration: 0,\n        renderedFrames: 0,\n    },\n\n    /**\n     * @param {Function} f a hook function to execute before each render cycle\n     * @return {Function} returns the function which has been passed in\n     */\n    addPreRenderHook: function(f) {\n        preRenderHooks.push(f);\n        scheduleNextFrame();\n\n        return f;\n    },\n\n    /**\n     * @param {Function} f - a hook function to execute after each render cycle\n     * @return {Function} returns the function which has been passed in.\n     */\n    addPostRenderHook: function(f) {\n        postRenderHooks.push(f);\n        scheduleNextFrame();\n\n        return f;\n    },\n\n    /**\n     * Removes a previously added pre render hook\n     *\n     * @param  {Function} f - the function which was previously added\n     * @return {*} - see Array.prototype.splice\n     */\n    removePreRenderHook: function(f) {\n        return preRenderHooks.splice(preRenderHooks.indexOf(f), 1);\n    },\n\n    /**\n     * Removes a previously added post render hook\n     *\n     * @param  {Function} f - the function which was previously added\n     * @return {*} {@link Array.prototype.splice}\n     */\n    removePostRenderHook: function(f) {\n        return postRenderHooks.splice(postRenderHooks.indexOf(f), 1);\n    },\n\n    /**\n     * @param {Function} f - the task to preform in the next render cycle.\n     * @param {string} [id] optional task id\n     * @return {Function} the function which has been passed in.\n     */\n    schedulePreRenderTask: function(f, id) {\n        preRenderTasks.push(f, id);\n        scheduleNextFrame();\n\n        return f;\n    },\n\n    /**\n     * @param {Function} f - the task to preform in the next render cycle.\n     * @param {string} [id] optional task id\n     * @return {Function} the function which has been passed in.\n     */\n    scheduleRenderTask: function(f, id) {\n        renderTasks.push(f, id);\n        scheduleNextFrame();\n\n        return f;\n    },\n\n    /**\n     * @param {Function} f - the task to preform after the next render cycle.\n     * @return {Function} the function which has been passed in.\n     */\n    schedulePostRenderTask: function(f) {\n        nextPostRenderTasks.push(f);\n        scheduleNextFrame();\n\n        return f;\n    },\n\n    /**\n     * Forces the engine to render a new frame even if there are no tasks\n     *\n     * @return {void}\n     */\n    renderFrame: function() {\n        if(!active) {\n            scheduleNextFrame();\n        }\n    }\n};\n\n/**\n * @member {module:RenderEngine~RenderEngine} RenderEngine\n * @static\n */\nexport default RenderEngine;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./af/modules/Canvas/lib/RenderEngine.js\n// module id = 3\n// module chunks = 0","/**\n * The make module consits of Make, getPrototypeOf and mixin.\n * See the documentation for each method to see what is does.\n * This module is part of the ApplicationFrame.\n * @module Make\n * @author Jovan Gerodetti\n * @copyright Jovan Gerodetti\n * @version 1.0\n */\n\n\n/**\n * Internal function to apply one objects propteries to a target object.\n *\n * @param {Object} target\n * @param {Object} source\n * @inner\n */\nvar apply = function (target, source) {\n    Object.keys(source).forEach(function(key){\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n\n    return target;\n};\n\n/**\n * Creates a new object with the given prototype.\n * If two arguments are passed in, the properties of the first object will be\n * applied to the new object.\n *\n * @param {Object} object\n * @param {Object} prototype\n * @return {function}\n */\nexport var Make = function(object, prototype) {\n    if(arguments.length < 2){\n        prototype = object;\n        object = null;\n    }\n\n    if (object === null) {\n        object = Object.create(prototype);\n    } else {\n        object = apply(Object.create(prototype), object);\n    }\n\n    var m = function(...args){\n        var make = object.make || object._make || function(){};\n\n        make.apply(object, args);\n\n        return object;\n    };\n\n    m.get = function(){ return object; };\n\n    return m;\n};\n\n/**\n * This method checks if the given prototype is in the prototype chain of\n * the given target object.\n *\n * @param {Object} object\n * @param {Object} prototype\n * @return {boolean}\n */\nexport var hasPrototype = function(object, prototype){\n    var p = Object.getPrototypeOf(object);\n\n    while(p !== null && p !== undefined){\n        if(typeof prototype == 'function')\n            prototype = prototype.prototype;\n\n        if(p == prototype)\n            return true;\n        else\n            p = Object.getPrototypeOf(p);\n    }\n\n    return false;\n};\n\n/**\n * Creates a new prototype mixing all the given prototypes. Incase two or more\n * prototypes contain the same propterty, the new prototype will return\n * the propterty of the first prototype in the list which contains it.\n *\n * @param {...Object} prototypes - the porotype object to combine\n * @return {Proxy} - the resulting proxy object\n */\nexport var Mixin = function(...prototypes){\n\n    return new Proxy(prototypes, MixinTrap);\n\n};\n\n/**\n * Internal function to find a proptery in a list of prototypes.\n *\n * @param {Object[]} prototypes\n * @param {string} key\n * @return {Object}\n */\nvar findProperty = function(prototypes, key) {\n    for (var i = 0; i < prototypes.length; i++) {\n        var item = prototypes[i];\n\n        if (item && item[key]) {\n            return item;\n        }\n    }\n\n    return undefined;\n};\n\n/**\n * Traps to create a mixin.\n */\nvar MixinTrap = {\n\n    'get' : function(prototypes, key) {\n        var object = findProperty(prototypes, key);\n\n        if (object && typeof object[key] === 'function') {\n            return object[key].bind(object);\n        }\n\n        return (object ? object[key] : null);\n    },\n\n    'set' : function(prototypes, key, value) {\n        var object = findProperty(prototypes, key);\n\n        if (object) {\n            object[key] = value;\n        } else {\n            prototypes[0][key] = value;\n        }\n\n        return true;\n    }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./af/util/make.js\n// module id = 4\n// module chunks = 0","import { Make } from '../../util/make.js';\nimport ApplicationInternal from './ApplicationInternal.js';\n\nlet Internal = new WeakMap();\n\n/** @lends Application.prototype */\nlet Application = {\n\n    /**\n    * Name of this application so other components can identify the application.\n    *\n    * @type {string}\n    */\n    name : '',\n\n    /**\n    * Some components may need to know the version of this applicaion.\n    *\n    * @type {string}\n    */\n    version : '0.0.0',\n\n    /**\n    * @type {string}\n    */\n    author : '',\n\n    /**\n    * @constructs\n    *\n    * @return {void}\n    */\n    _make : function(){\n        Internal.set(this, Make(ApplicationInternal)());\n    },\n\n    /**\n    * Initializes this application, default interface for components and modules.\n    *\n    * @return {void}\n    */\n    init : function(){\n        console.log(`Initialzing Application \"${this.name}\"!`);\n    },\n\n\n    /**\n    * Registers a new event listener for the given event type.\n    *\n    * @param {string} type the event type\n    * @param {function} listener the listener function\n    *\n    * @return {Application} this application\n    */\n    on : function(type, listener){\n        let scope = Internal.get(this);\n\n        if (!scope.listeners[type]) {\n            scope.listeners[type] = [];\n        }\n\n        scope.listeners[type].push(listener);\n\n        return this;\n    },\n\n    /**\n    * removes a previously attached listener function.\n    *\n    * @param  {string} type     the listener type\n    * @param  {Function} listener the listener function to remove\n    *\n    * @return {void}\n    */\n    removeListener: function(type, listener) {\n        let scope = Internal.get(this);\n\n        if (scope.listeners[type]) {\n            let index = scope.listeners[type].indexOf(listener);\n\n            scope.listeners[type].splice(index, 1);\n        }\n    },\n\n    /**\n    * Emmits a new event on this application.\n    *\n    * @param {string} type event type\n    * @param {Object} data event data\n    *\n    * @return {void}\n    */\n    emit : function(type, data){\n        let scope = Internal.get(this);\n        let name = this.name ? `${this.name}:%c ` : '%c%c';\n\n        if (scope.listeners[type]) {\n            console.log(`%c${name}${type} event emitted`,\n                'font-weight: 900; text-decoration: underline;',\n                'font-weight: initial; text-decoration: initial;');\n\n            setTimeout(() => scope.listeners[type].forEach(f => f(data)), 0);\n        }\n    },\n\n    /**\n    * This function will try to terminate the application by emitting the termination event.\n    *\n    * @param {string} reason - the reason for the termination.\n    *\n    * @return {void}\n    */\n    terminate : function(reason){\n        this.emit('terminate', reason);\n    }\n\n};\n\nexport default Application;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./af/core/prototypes/Application.js\n// module id = 5\n// module chunks = 0","import VisualComponent from '../lib/VisualComponent';\n\nconst Box = {\n\n    color: '#fff',\n\n    /**\n     * @param {HTMLCanvasElement} canvasManager - the target canvas\n     *\n     * @return {ImageData} - the resulting pixel data\n     */\n    render(canvasManager) {\n        super.render(canvasManager);\n\n        const context = canvasManager.getCanvas(this);\n\n        context.fillStyle = this.color;\n        context.fillRect(0, 0, context.canvas.width, context.canvas.height);\n\n        return context.canvas;\n    },\n\n    __proto__: VisualComponent,\n};\n\nexport default Box;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./af/modules/Canvas/Prototypes/Box.js\n// module id = 6\n// module chunks = 0","import VisualComponent from '../lib/VisualComponent';\n\nconst TextBlock = {\n\n    text: '',\n    font: 'sans-serif',\n    color: '#000',\n    alignment: 'left',\n    fontSize: 12,\n\n    textInBound(context, text) {\n        return context.measureText(text).width <= this.width;\n    },\n\n    applyTextWrapping(context, text) {\n\n        // first, get the actual lines.\n        const actualLines = text.split('\\n');\n\n        // now check for line overflow.\n        const lines = [];\n\n        // go through every line\n        actualLines.forEach(line => {\n            line = line.split(' ');\n            let lineContent = line.shift();\n\n            // as long as we still have words in our source line\n            while (line.length) {\n\n                // our line didn't excede the box width so we can push more\n                // words to our current line\n                if (this.textInBound(context, `${lineContent} ${line[0]}`)) {\n                    lineContent += ` ${line.shift()}`;\n\n                // line is full push it to the stack of lines\n                } else {\n                    lines.push(lineContent);\n                    lineContent = line.shift();\n                }\n            }\n\n            // we are done processing the source line, get rid of the remaining line\n            lines.push(lineContent);\n        });\n\n        return lines;\n    },\n\n    render(canvasManager) {\n        super.render(canvasManager);\n\n        const context = canvasManager.getCanvas(this);\n\n        // setup context for rendering\n        context.font = `${this.fontSize}px ${this.font}`;\n        context.textAlign = this.alignment;\n        context.fillStyle = this.color;\n        context.textBaseline = 'top';\n\n        // process the text, word wrapping and everything!\n        const lines = this.applyTextWrapping(context, this.text);\n        const x = (this.alignment === 'center') ? (this.x / 2) : this.x;\n\n        lines.forEach((line, index) => {\n            context.fillText(line, x, this.fontSize * index);\n        });\n\n        return context.canvas;\n    },\n\n    __proto__: VisualComponent,\n};\n\nexport default TextBlock;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./af/modules/Canvas/Prototypes/TextBlock.js\n// module id = 7\n// module chunks = 0","export { default as default } from './lib/Canvas';\n\n// Classes\n/** export let CImage =  Make({\n    crop : null,\n    source : null,\n    _width: 0,\n    _height: 0,\n\n    _make : function(source, x, y, zLevel){\n        RectShapeElement._make.apply(this, [x, y, null, null, zLevel]);\n\n        this.source = source;\n    },\n\n    render : function(context, canvas) {\n        /** @type {ElementMetaData}\n        let metaData = elementMetaData.get(this);\n\n        if (!metaData.isRendered) {\n            Element.render.apply(this, [context, canvas]);\n\n            canvas.save();\n            canvas.globalAlpha = verifyOpacity(canvas.globalAlpha - (1-this.opacity));\n            if (this.crop) {\n                let sourceX = this.crop.left;\n                let sourceY = this.crop.top;\n                let sourceWidth = this.source.naturalWidth - this.crop.left - this.crop.right;\n                let sourceHeight = this.source.naturalHeight - this.crop.top - this.crop.bottom;\n                let targetX = context.xOffset + this.x;\n                let targetY = context.yOffset + this.y;\n                canvas.drawImage(this.source, sourceX, sourceY, sourceWidth, sourceHeight, targetX, targetY, this.width, this.height);\n            }else{\n                canvas.drawImage(this.source, context.xOffset + this.x, context.yOffset + this.y, this.width, this.height);\n            }\n            canvas.restore();\n        }\n    },\n\n    get width() {\n        return this._width || this.source.naturalWidth || 0;\n    },\n\n    set width(width) {\n        this._width = width;\n    },\n\n    get height() {\n        return this._height || this.source.naturalHeight || 0;\n    },\n\n    set height(height) {\n        this._height = height;\n    }\n}, RectShapeElement).get();\n\nexport let HitArea = Make({\n\n    render : function(){}\n\n}, RectShapeElement).get();\n\nexport let ImageCrop = {\n    top : 0,\n    right : 0,\n    bottom : 0,\n    left : 0,\n\n    _make : function(top=0, right=0, bottom=0, left=0){\n        this.top = top;\n        this.right = right;\n        this.bottom = bottom;\n        this.left = left;\n    }\n};\n\n// animations\nexport let fadeOut = function(element, time, callback){\n    let timeOut = 20; // milliseconds\n    time *= 1000;     //convert to milliseconds\n    let updates = Math.round(time / timeOut);\n    let ammount = 1 / updates;\n\n    let update = function() {\n        updates--;\n        element.opacity -= ammount;\n\n        if(updates > 0)\n            window.setTimeout(update, timeOut);\n        else if(callback){\n            element.opacity = 0;\n            callback();\n        }\n    };\n\n    element.opacity = 1;\n    update();\n};\n\nexport let fadeIn = function(element, time, callback){\n    let timeOut = 20; // milliseconds\n    time *= 1000;     //convert to milliseconds\n    let updates = Math.round(time / timeOut);\n    let ammount = 1 / updates;\n\n    let update= function() {\n        updates--;\n        element.opacity += ammount;\n\n        if(updates > 0)\n            window.setTimeout(update, timeOut);\n        else if(callback){\n            element.opacity= 1;\n            callback();\n        }\n    };\n\n    element.opacity= 0;\n    update();\n};\n\nexport let zoomIn = function(element, target, amount, time, callback) {\n    if (!hasPrototype(element, CImage)) {\n        console.error('element is not a instance of CImage');\n        return false;\n    }\n\n    let topAmount = Math.round((target[1] / 100) * amount);\n    let leftAmount = Math.round((target[0] / 100) * amount);\n    let bottomAmount = Math.round(((element.height - target[1]) / 100) * amount);\n    let rightAmount = Math.round(((element.width - target[0]) / 100) * amount);\n    time *= 1000; // to milliseconds\n    let timeOut = 20;\n    let updates = Math.round(time / timeOut);\n    let lot = 1 / updates;\n\n    let update = function(){\n        updates--;\n        element.crop.top += topAmount * lot;\n        element.crop.right += rightAmount * lot;\n        element.crop.bottom += bottomAmount * lot;\n        element.crop.left += leftAmount * lot;\n\n        if (updates > 0) {\n            window.setTimeout(update, timeOut);\n        } else if(callback) {\n            callback();\n        }\n    };\n\n    if (!element.crop) {\n        element.crop = Make(ImageCrop)();\n    }\n    update();\n};\n\nexport let zoomOut = function(element, target, amount, time, callback) {\n    if(!(element instanceof CImage)){\n        console.error('element is not a instance of CImage');\n        return false;\n    }\n\n    let topAmount = Math.round((target[1] / 100) * amount);\n    let leftAmount = Math.round((target[0] / 100) * amount);\n    let bottomAmount = Math.round(((element.height - target[1]) / 100) * amount);\n    let rightAmount = Math.round(((element.width - target[0]) / 100) * amount);\n    time *= 1000; // to milliseconds\n    let timeOut = 20;\n    let updates = Math.round(time / timeOut);\n    let lot = 1 / updates;\n\n    let update = function() {\n        updates--;\n        element.crop.top -= topAmount * lot;\n        element.crop.right -= rightAmount * lot;\n        element.crop.bottom -= bottomAmount * lot;\n        element.crop.left -= leftAmount * lot;\n\n        if (updates > 0) {\n            window.setTimeout(update, timeOut);\n        }else if(callback){\n            element.crop = null;\n            callback();\n        }\n    };\n    if (!element.crop) {\n        element.crop = Make(ImageCrop)(topAmount, rightAmount, bottomAmount, leftAmount);\n    }\n    update();\n}; **/\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./af/modules/Canvas/main.js\n// module id = 8\n// module chunks = 0","import Image from './af/modules/Canvas/Prototypes/Image';\n\nconst ASSETS_BASE_PATH = 'assets/';\n\nexport const BLOCK_UPPER_SPACE = 50;\nexport const BLOCK_HEIGHT = 41;\nexport const BLOCK_SIZE = 80;\n\nconst asset = function(fileName) {\n    return Image.load(`${ASSETS_BASE_PATH}${fileName}`);\n};\n\nconst Assets = {\n    blocks: {\n        grass: asset('Grass Block.png'),\n        basic: asset('Brown Block.png'),\n        plain: asset('Plain Block.png'),\n        wood: asset('Wood Block.png'),\n        water: asset('Water Block.png'),\n        dirt: asset('Dirt Block.png'),\n        stone: {\n            normal: asset('Stone Block.png'),\n            tall: asset('Stone Block Tall.png'),\n        },\n        shadow: {\n            east: asset('Shadow East.png'),\n            northEast: asset('Shadow North East.png'),\n            northWest: asset('Shadow North West.png'),\n            north: asset('Shadow North.png'),\n            sideWest: asset('Shadow Side West.png'),\n            southEast: asset('Shadow South East.png'),\n            southWest: asset('Shadow South West.png'),\n            south: asset('Shadow South.png'),\n            west: asset('Shadow West.png'),\n        }\n    },\n\n    chars: {\n        boy: asset('Character Boy.png'),\n        girl: {\n            pink: asset('Character Pink Girl.png'),\n        }\n    }\n};\n\nexport default Assets;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets.js\n// module id = 9\n// module chunks = 0","const Map = {\n\n    size: [5, 8],\n\n    data: [\n        [\n            [   null,    null,    null,    null, 'grass'],\n            [   null,    null,    null,    null, 'grass'],\n            [   null,    null,    null,    null, 'grass'],\n            [   null, 'grass',    null,    null, 'grass'],\n            [   null,    null,    null,    null, 'grass'],\n        ],\n        [\n            ['grass', 'grass', 'grass', 'grass',   null, 'grass'],\n            ['grass', 'grass', 'grass', 'grass',   null, 'grass'],\n            ['grass', 'grass', 'grass', 'grass',   null, 'grass'],\n            ['grass', 'grass', 'grass', 'grass',   null, 'grass'],\n            ['grass', 'grass', 'grass', 'grass', 'dirt', 'grass'],\n        ],\n        [\n            [  null,    null,    null,    null,    null,    null,  'dirt',  'dirt'],\n            [  null,    null,    null,    null,    null,    null,  'dirt',  'dirt'],\n            [  null,    null,    null,    null,    null,    null,  'dirt',  'dirt'],\n            [  null,    null,    null,    null,    null,  'dirt',    null,  'dirt'],\n            ['dirt',  'dirt',  'dirt',  'dirt',  'dirt',  'dirt',  'dirt',  'dirt'],\n        ]\n    ]\n};\n\nexport default Map;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./map.js\n// module id = 10\n// module chunks = 0","\n/** @lends ApplicationInternal# */\nlet ApplicationInternal = {\n    /**\n     * @type {Thread}\n     */\n    thread : null,\n\n    /**\n     * @type {Worker[]}\n     */\n    workers : null,\n\n    /**\n     * @type {Function[]}\n     */\n    listeners : null,\n\n    /**\n     * @type {Catalog}\n     */\n    modules : null,\n\n    /**\n     * this prototype defines a new application scope\n     *\n     * @constructs\n     *\n     * @return {void}\n     */\n    _make : function(){\n        this.workers= [];\n        this.listeners= [];\n\n        this._make = null;\n    }\n};\n\nexport default ApplicationInternal;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./af/core/prototypes/ApplicationInternal.js\n// module id = 11\n// module chunks = 0","import VisualComponent from './../lib/VisualComponent';\n\nconst Image = {\n\n    image: null,\n\n    /**\n     * @static\n     * @param {string} src - the url of the image\n     *\n     * @return {Promise<Image>} - a promise with the image object\n     */\n    load(src) {\n        const file = new window.Image();\n        file.src = src;\n\n        return new Promise((success, error) => {\n            file.onload = success;\n            file.onerror = error;\n        }).then(() => {\n            return Object.create(Image).constructor({\n                image: file,\n                height: file.naturalHeight,\n                width: file.naturalWidth,\n            });\n        });\n    },\n\n    render(canvasManager) {\n        if (this.offsetX !== 0 || this.offsetY !== 0) {\n            super.render(canvasManager);\n            const context = canvasManager.getCanvas(this);\n\n            context.drawImage(this.image, this.offsetX, this.offsetY);\n\n            return context.canvas;\n        } else {\n            return this.image;\n        }\n    },\n\n    __proto__: VisualComponent,\n};\n\nexport default Image;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./af/modules/Canvas/Prototypes/Image.js\n// module id = 12\n// module chunks = 0","import Layer from './Layer';\nimport RenderManager from './RenderManager';\n\nconst Canvas = {\n\n    drawContext: null,\n    element: null,\n    resolution: 1,\n\n    get width() {\n        return this.element.width;\n    },\n\n    get height() {\n        return this.element.height;\n    },\n\n    $isRoot: true,\n\n    constructor(canvasSelector, resolution = 1) {\n        super.constructor({});\n\n        this.element = document.querySelector(canvasSelector);\n        this.drawContext = this.element.getContext('2d', { alpha: false });\n        this.resolution = resolution;\n\n        this.element.setAttribute('width', this.element.offsetWidth);\n        this.element.setAttribute('height', this.element.offsetHeight);\n\n        return this;\n    },\n\n    startRendering() {\n        RenderManager.start();\n    },\n\n    stopRendering() {\n        RenderManager.stop();\n    },\n\n    __proto__: Layer,\n};\n\nexport default Canvas;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./af/modules/Canvas/lib/Canvas.js\n// module id = 13\n// module chunks = 0","const canvasMap = new WeakMap();\n\nconst RenderCanvasManager = {\n    getCanvas(object) {\n        let canvas = canvasMap.get(object);\n\n        if (!canvas) {\n            canvas = document.createElement('canvas').getContext('2d');\n\n            canvasMap.set(object, canvas);\n        }\n\n        return canvas;\n    }\n};\n\nexport default RenderCanvasManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./af/modules/Canvas/lib/RenderCanvasManager.js\n// module id = 14\n// module chunks = 0","\n/** @lends module:RenderEngine.TaskList.prototype */\nlet TaskList = {\n\n    /** @type Array */\n    tasks: null,\n\n    /** @type Array */\n    registeredIds: null,\n\n    /**\n     * Render TaskList to manage rendertaks and optionally track duplicates by ids.\n     *\n     * @constructs\n     * @return {void}\n     */\n    _make: function() {\n        this.tasks = [];\n        this.registeredIds = [];\n    },\n\n    /**\n     * adds a new item to the task list.\n     *\n     * @param  {Function} task the task to add to the list\n     * @param  {string} [id] the id of this tasks. If provided no task with the same id can be added again.\n     * @return {void}\n     */\n    push: function(task, id) {\n        if (!id || this.registeredIds.indexOf(id) < 0) {\n            this.tasks.push(task);\n\n            if (id) {\n                this.registeredIds.push(id);\n            }\n        }\n    },\n\n    /** @type {number} */\n    get length() {\n        return this.tasks.length;\n    },\n\n    flush: function() {\n        this.tasks = [];\n        this.registeredIds = [];\n    }\n};\n\nexport default TaskList;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./af/modules/Canvas/lib/RenderEngine/TaskList.js\n// module id = 15\n// module chunks = 0","import Application from './af/core/prototypes/Application';\nimport Canvas from './af/modules/Canvas';\nimport Box from './af/modules/Canvas/Prototypes/Box';\nimport Layer from './af/modules/Canvas/lib/Layer';\nimport TextBlock from './af/modules/Canvas/Prototypes/TextBlock';\nimport RenderEngine from './af/modules/Canvas/lib/RenderEngine';\nimport { default as Assets, BLOCK_SIZE, BLOCK_UPPER_SPACE, BLOCK_HEIGHT } from './assets';\nimport Map from './map';\n\nconst CHAR_PADDING = -35;\n\nconst App = {\n\n    canvas: null,\n\n    init([GrassBlock, DirtBlock, ShadowEast, ShadowWest, ShadowNorth, ShadowSouth, CharBoy]) {\n        this.canvas = Object.create(Canvas).constructor('#canvas');\n\n        const randomGuy = Object.create(CharBoy);\n        const currentMapLevel = 1;\n        const heightLevel = (currentMapLevel * BLOCK_HEIGHT);\n\n        randomGuy.offsetY = CHAR_PADDING;\n        randomGuy.setProperty('y', heightLevel);\n\n        const walkableMap = Object.create(Layer).constructor({\n            x: 0,\n            y: 0,\n            height: BLOCK_UPPER_SPACE + (BLOCK_SIZE * 4),\n            width: GrassBlock.width * 4,\n        });\n\n        walkableMap.addChild(randomGuy);\n\n        const layer2 = Object.create(Layer).constructor({\n            x: 50,\n            y: 50,\n            height: 50,\n            width: 150,\n        });\n\n        const someText = Object.create(TextBlock).constructor({\n            height: 50,\n            width: 150,\n            text: ''\n        });\n\n        layer2.addChild(someText);\n\n        this.canvas.addChild(Object.create(Box).constructor({ width: this.canvas.width, height: this.canvas.height }));\n        this.buildMap(Map, DirtBlock, ShadowWest, GrassBlock, ShadowEast, ShadowNorth, ShadowSouth);\n\n        walkableMap.addChild(layer2);\n        this.canvas.addChild(walkableMap);\n        this.canvas.startRendering();\n\n        setInterval(() => {\n            const heightLevel = (currentMapLevel * BLOCK_HEIGHT);\n\n            if (randomGuy.x === GrassBlock.width * 3 && randomGuy.y < heightLevel + BLOCK_SIZE) {\n                randomGuy.setProperty('y', randomGuy.y + 1);\n            } else if (randomGuy.x > 0 && randomGuy.y === heightLevel + BLOCK_SIZE){\n                randomGuy.setProperty('x', randomGuy.x - 1);\n            } else if (randomGuy.x === 0 && randomGuy.y > heightLevel) {\n                randomGuy.setProperty('y', randomGuy.y - 1);\n            } else {\n                randomGuy.setProperty('x', randomGuy.x + 1);\n            }\n\n            const fps = Math.round(RenderEngine.performance.fps);\n            const frames = Math.round(RenderEngine.performance.renderedFrames);\n            const duration = Math.round(RenderEngine.performance.lastFrameDuration);\n\n            someText.setProperty('text', `FPS: ${fps}\\nRenderedFrames: ${frames}\\nFrameDuration: ${duration}ms`);\n        }, 10);\n    },\n\n    buildMap(map, DirtBlock, ShadowWest, GrassBlock, ShadowEast, ShadowNorth, ShadowSouth) {\n        let { size: mapSize } = map;\n        map = map.data;\n\n        const mapContainer = Object.create(Layer).constructor({\n            height: BLOCK_UPPER_SPACE + (BLOCK_SIZE * mapSize[0]) + BLOCK_HEIGHT,\n            width: GrassBlock.width * mapSize[1],\n        });\n\n        const mapping = {\n            'grass': GrassBlock,\n            'dirt': DirtBlock,\n        };\n\n        for (let i = map.length-1; i > -1; i--) {\n            const layer = map[i];\n            const container = Object.create(Layer).constructor({\n                y: BLOCK_HEIGHT * i,\n                height: BLOCK_UPPER_SPACE + (BLOCK_SIZE * layer.length) + BLOCK_HEIGHT,\n                width: GrassBlock.width * Math.max(...layer.map(item => item.length)),\n            });\n\n            for (let r = 0; r < layer.length; r++) {\n                const blockRow = layer[r];\n\n                for (let b = 0; b < blockRow.length; b++) {\n                    const blockType = blockRow[b];\n\n                    if (blockType) {\n                        const block = Object.create(mapping[blockType]);\n\n                        block.setProperty('x', GrassBlock.width * b);\n                        block.setProperty('y', BLOCK_SIZE * r);\n\n                        if (map[i+1] && map[i+1][r-1] && map[i+1][r-1][b] && !map[i][r-1][b]) {\n                            const shadow = Object.create(ShadowSouth);\n\n                            shadow.setProperty('y', BLOCK_SIZE * (r-1) + BLOCK_HEIGHT);\n                            shadow.setProperty('x', GrassBlock.width * b);\n                            container.addChild(shadow);\n                        }\n\n                        container.addChild(block);\n\n                        // if there is a block one layer lower and one to the left, but\n                        // no block on the same layer and one to the left\n                        if (map[i+1] && map[i+1][r][b-1] && !map[i][r][b-1]) {\n                            const shadow = Object.create(ShadowEast);\n\n                            shadow.setProperty('y', (BLOCK_SIZE * r) + BLOCK_HEIGHT);\n                            shadow.setProperty('x', GrassBlock.width * (b-1));\n\n                            container.addChild(shadow);\n                        }\n\n                        if (map[i+1] && map[i+1][r][b+1] && !map[i][r][b+1]) {\n                            const shadow = Object.create(ShadowWest);\n\n                            shadow.setProperty('y', (BLOCK_SIZE * r) + BLOCK_HEIGHT);\n                            shadow.setProperty('x', GrassBlock.width * (b+1));\n                            container.addChild(shadow);\n                        }\n\n                        if (map[i+1] && map[i+1][r+1] && map[i+1][r+1][b] && !map[i][r+1][b]) {\n                            const shadow = Object.create(ShadowNorth);\n\n                            shadow.setProperty('y', BLOCK_SIZE * (r+1) + BLOCK_HEIGHT);\n                            shadow.setProperty('x', GrassBlock.width * b);\n                            container.addChild(shadow);\n                        }\n                    }\n                }\n            }\n\n            mapContainer.addChild(container);\n        }\n\n        this.canvas.addChild(mapContainer);\n    },\n\n    __proto__: Application,\n};\n\nPromise.all([\n    Assets.blocks.grass,\n    Assets.blocks.dirt,\n    Assets.blocks.shadow.east,\n    Assets.blocks.shadow.west,\n    Assets.blocks.shadow.north,\n    Assets.blocks.shadow.south,\n    Assets.chars.boy,\n]).then(App.init.bind(App));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./main.js\n// module id = 16\n// module chunks = 0"],"sourceRoot":""}